// Copyright Epic Games, Inc. All Rights Reserved.

#include "ClingRuntime.h"
#include "Misc/MessageDialog.h"
#include "Modules/ModuleManager.h"
#include "Interfaces/IPluginManager.h"
#include "Misc/Paths.h"
#include "HAL/PlatformProcess.h"
#include <algorithm>
#include "cling/Interpreter/Interpreter.h"
#include "Engine/Engine.h"
#include "cling-demo.h"
#include "ClingSetting.h"
#include "ClingLog/ClingLog.h"
#include "ClingLog/LogRedirector.h"
#if PLATFORM_WINDOWS
#include <windows.h>
#endif
#define LOCTEXT_NAMESPACE "FClingRuntimeModule"

FString GetLLVMDir()
{
	FString BaseDir = IPluginManager::Get().FindPlugin("UECling")->GetBaseDir();
	return FPaths::ConvertRelativePathToFull(BaseDir/TEXT("Source/ThirdParty/ClingLibrary/LLVM"));	
}
FString GetLLVMInclude()
{
	return GetLLVMDir()/TEXT("include");
}

void FClingRuntimeModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module

	// Get the base directory of this plugin
	FString BaseDir = IPluginManager::Get().FindPlugin("UECling")->GetBaseDir();

	// Add on the relative location of the third party dll and load it
	FString LibraryPath;
#if PLATFORM_WINDOWS
	LibraryPath = FPaths::Combine(*BaseDir, TEXT("Source/ThirdParty/ClingLibrary/LLVM/bin/"));
	// TArray<FString> DynamicLinkNames{"libclang.dll", "libcling", "libclingJupyter.dll",	"LLVM-C.dll", "LTO.dll", "Remarks.dll", "RelWithDebInfo/cling-demo.dll"};
#elif PLATFORM_MAC
    LibraryPath = FPaths::Combine(*BaseDir, TEXT("Source/ThirdParty/ClingLibrary/Mac/Release/libExampleLibrary.dylib"));
#elif PLATFORM_LINUX
	LibraryPath = FPaths::Combine(*BaseDir, TEXT("Binaries/ThirdParty/ClingLibrary/Linux/x86_64-unknown-linux-gnu/libExampleLibrary.so"));
#endif // PLATFORM_WINDOWS
	
	FString LLVMDir = FPaths::ConvertRelativePathToFull(BaseDir/TEXT("Source/ThirdParty/ClingLibrary/LLVM"));
	FString LLVMInclude = LLVMDir/TEXT("include");
	
	FString RelativePath = FPaths::ConvertRelativePathToFull(TEXT(".."));
	FString UE_Exec = FPlatformProcess::ExecutablePath();
	
#if PLATFORM_WINDOWS
	// BOOL result = SetEnvironmentVariable(TEXT("CLING_DEBUG"), TEXT("1"));
	int result = _putenv("CLING_DEBUG=1");
#endif
	// -g -gcodeview -gno-column-info
	
	FLogRedirector::RedirectToUELog();
	
	UClingSetting* Setting = GetMutableDefault<UClingSetting>();
	Setting->RefreshIncludePaths();
	BaseInterp = StartInterpreterInternal(true);
	Interps.Add_GetRef(BaseInterp);
	StartNewInterp();
	// Include file of all global definitions of build context export by UnrealBuildTool 
	UE_Exec.ReplaceCharInline('\\','/');
	FString GlobalDefinesFilePath = UE_Exec/TEXT("../UECling/BuildGlobalDefines.h");
	Decalre(BaseInterp,StringCast<ANSICHAR>(*(TEXT("#include \"")+GlobalDefinesFilePath+TEXT("\""))).Get());

	// Load file contains all module build infos
	// AddIncludePath(BaseInterp,StringCast<ANSICHAR>(*FPaths::EngineSourceDir()).Get());
	// for (auto& ModuleBuildInfo : Setting->ModuleBuildInfos)
	// {
	// 	// Begin IncludePaths
	// 	for (const auto& PublicIncludePath : ModuleBuildInfo.Value.PublicIncludePaths)
	// 	{
	// 		AddIncludePath(BaseInterp,StringCast<ANSICHAR>(*PublicIncludePath).Get());
	// 	}
	// 	// We don't need to add Private Include Path! A module should not add path to headers
	// 	// that can be include by other module in PrivateIncludePaths		
	// 	// for (const auto& PrivateIncludePath : ModuleBuildInfo.Value.PrivateIncludePaths)
	// 	// {
	// 	// 	AddIncludePath(Interp,StringCast<ANSICHAR>(*PrivateIncludePath).Get());
	// 	// }
	//
	// 	for (const auto& PrivateIncludePath : ModuleBuildInfo.Value.PublicSystemIncludePaths)
	// 	{
	// 		AddIncludePath(BaseInterp,StringCast<ANSICHAR>(*PrivateIncludePath).Get());
	// 	}
	// 	// Begin Definitions
	// 	// Todo Ignore LAUNCH_API since it is defined in BuildGlobalDefines.h generated by us
	// 	FString MacroDefine = TEXT("#define ") + ModuleBuildInfo.Value.Name.ToString().ToUpper() + TEXT("_API ");
	// 	Decalre(BaseInterp,StringCast<ANSICHAR>(*MacroDefine).Get());
	// 	for (FString& Define : ModuleBuildInfo.Value.PublicDefinitions)
	// 	{
	// 		Define.ReplaceCharInline('=',' ');
	// 		Decalre(BaseInterp,StringCast<ANSICHAR>(*(TEXT("#define ")+Define)).Get());
	// 	}
	// 	if(!ModuleBuildInfo.Value.Directory.Contains(TEXT("Engine/Source")))
	// 		AddIncludePath(BaseInterp,StringCast<ANSICHAR>(*ModuleBuildInfo.Value.Directory).Get());
	// }
	// for (const auto& GeneratedHeaderIncludePath : Setting->GeneratedHeaderIncludePaths)
	// {
	// 	AddIncludePath(BaseInterp,StringCast<ANSICHAR>(*GeneratedHeaderIncludePath).Get());
	// }
// #ifdef _MSC_VER
// #define EVA_MACRO(_M) #_M
// #define STR_MACRO(_M) "#define " #_M " " EVA_MACRO(_M)	
// 	Decalre(Interp,StringCast<ANSICHAR>(TEXT(STR_MACRO(_MSC_VER))).Get());
// 	Decalre(Interp,StringCast<ANSICHAR>(TEXT(STR_MACRO(_WIN64))).Get());
// #endif
	// Declare some files which are general in Unreal
#ifdef __clang__
#else 
	Decalre(BaseInterp,"#include \"Microsoft/MinimalWindowsApi.h\"");
	Decalre(BaseInterp,"#include \"Runtime/Core/Private/Microsoft/MinimalWindowsApi.cpp\"");
#endif
	Decalre(BaseInterp,"#include \"CoreMinimal.h\"");
	Decalre(BaseInterp,"#include \"UObject/Object.h\"");
	Decalre(BaseInterp,"#include \"Logging/LogMacros.h\"");
	Decalre(BaseInterp,"#define WITH_CLING 1");
	Decalre(BaseInterp,"#include \"Restart3.h\"");
	if(Setting->bAllowRedefine)
		Execute(BaseInterp,"gClingOpts->AllowRedefinition = true;");
	
	Execute(GetInterp(),"gClingOpts->AllowRedefinition = true;");
}

void FClingRuntimeModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.

	// Free the dll handle
	for (auto& Handle: ExampleLibraryHandles)
	{
		FPlatformProcess::FreeDllHandle(Handle);
		Handle = nullptr;
	}
	ExampleLibraryHandles.Reset();

	delete BaseInterp;
}

cling::Interpreter* FClingRuntimeModule::GetInterp(int Version)
{
	const int id = Interps.Num()-Version-1;
	if(Interps.IsValidIndex(id))
		return Interps[id];
	UE_LOG(LogCling,Log,TEXT("Invalid version of Interpreter!"));
	return Interps[Interps.Num()-1];
}

cling::Interpreter* FClingRuntimeModule::StartNewInterp()
{
	return Interps.Add_GetRef(StartInterpreterInternal(false));
}

cling::Interpreter* FClingRuntimeModule::StartInterpreterInternal(bool bBaseInterp)
{
	FString LLVMDir = GetLLVMDir();
	FString LLVMInclude = GetLLVMInclude();
	FString UE_Exec = FPlatformProcess::ExecutablePath();
	UClingSetting* Setting = GetMutableDefault<UClingSetting>();
	// Start ClingInterpreter
	TArray<const char*> Argv;
	cling::Interpreter* Interpreter{nullptr};
	Argv.Add(StringCast<ANSICHAR>(*UE_Exec).Get());
	Argv.Add("-I");
	Argv.Add(StringCast<ANSICHAR>(*LLVMInclude).Get());
	if(bBaseInterp)
	{
		// Forbid RTTI	
		// Argv.Add("-fno-rtti");
		if(Setting->bVerbose)
			Argv.Add("-v");
		if(Setting->bIgnoreMissingOverride)
			Argv.Add("-Wno-inconsistent-missing-override");
		if(Setting->bIgnoreInvalidOffsetOf)
			Argv.Add("-Wno-invalid-offsetof");	
		if(Setting->bIgnoreDeprecatedEnumEnumConversion)
			Argv.Add("-Wno-deprecated-enum-enum-conversion");
		if(Setting->bIgnoreInCompleteSwitch)
			Argv.Add("-Wno-switch");
		if(Setting->bIgnoreAutoLogicalUndefinedCompare)
			Argv.Add("-Wno-tautological-undefined-compare");
		if(Setting->bIgnoreStringLiteralOperatorTemplate)
			Argv.Add("-Wno-gnu-string-literal-operator-template");
		Argv.Add("-march=native");
		// Todo #include "HAL/Platform.h"
		Interpreter = CreateInterp(Argv.Num(), Argv.GetData(), StringCast<ANSICHAR>(*LLVMDir).Get());
	}
	if(BaseInterp)
	{
		// Argv.Add("Cling");
		Interpreter = CreateChildInterp(*BaseInterp,Argv.Num(), Argv.GetData(), StringCast<ANSICHAR>(*LLVMDir).Get());
	}

	AddIncludePath(Interpreter,StringCast<ANSICHAR>(*FPaths::EngineSourceDir()).Get());
	for (auto& ModuleBuildInfo : Setting->ModuleBuildInfos)
	{
		// Begin IncludePaths
		for (const auto& PublicIncludePath : ModuleBuildInfo.Value.PublicIncludePaths)
		{
			AddIncludePath(Interpreter,StringCast<ANSICHAR>(*PublicIncludePath).Get());
		}
		// We don't need to add Private Include Path! A module should not add path to headers
		// that can be include by other module in PrivateIncludePaths		
		// for (const auto& PrivateIncludePath : ModuleBuildInfo.Value.PrivateIncludePaths)
		// {
		// 	AddIncludePath(Interp,StringCast<ANSICHAR>(*PrivateIncludePath).Get());
		// }

		for (const auto& PrivateIncludePath : ModuleBuildInfo.Value.PublicSystemIncludePaths)
		{
			AddIncludePath(Interpreter,StringCast<ANSICHAR>(*PrivateIncludePath).Get());
		}
		// Begin Definitions
		// Todo Ignore LAUNCH_API since it is defined in BuildGlobalDefines.h generated by us
		FString MacroDefine = TEXT("#define ") + ModuleBuildInfo.Value.Name.ToString().ToUpper() + TEXT("_API ");
		Decalre(Interpreter,StringCast<ANSICHAR>(*MacroDefine).Get());
		for (FString& Define : ModuleBuildInfo.Value.PublicDefinitions)
		{
			Define.ReplaceCharInline('=',' ');
			Decalre(Interpreter,StringCast<ANSICHAR>(*(TEXT("#define ")+Define)).Get());
		}
		if(!ModuleBuildInfo.Value.Directory.Contains(TEXT("Engine/Source")))
			AddIncludePath(Interpreter,StringCast<ANSICHAR>(*ModuleBuildInfo.Value.Directory).Get());
	}
	for (const auto& GeneratedHeaderIncludePath : Setting->GeneratedHeaderIncludePaths)
	{
		AddIncludePath(Interpreter,StringCast<ANSICHAR>(*GeneratedHeaderIncludePath).Get());
	}	
	return Interpreter;
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FClingRuntimeModule, ClingRuntime)
